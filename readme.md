# Алгоритм Краскала
Данный алгоритм позволяет достаточно эффективно найти минимальное остовное дерево в связном графе.

## Постановка задачи
В файле `input.txt` в виде матрицы расстояний записан граф. Требуется найти минимальное остовное дерево с помощью алгоритма Краскала и вывести в файл `output.txt` суммарную длину всех его рёбер, а так же сами эти рёбра.

## Псевдокод    
    G = граф
    E = список рёбер G
    удаляем все рёбра из G
    сортируем E по неубыванию длин
    T = пустой список рёбер минимального остовного дерева
    для каждого ребра e из E:
        a, b = вершины ребра e
        если a и b находятся в разных компонентах связности G:
            добавить в T ребро e
            объединить компоненты связности a и b ребром e

## Структуры данных
Ребро представлено в виде структуры, где `a` и `b` это вершины, которые ребро соединяет, а `l` это длина ребра.
```cpp
struct Edge {
    int a, b, l;
    ...
};
```
Изначальный граф и остовное дерево будем хранить в виде списков рёбер `std::vector<Edge>`. Для проверки и объединения компонент связности будем использовать СНМ, которая представлена в коде классом `DSU`.
```cpp
class DSU {
private:
    std::vector<int> parent, rank;
    int size = 0;
    ...
public:
    ...
    void make_set(int x) { ... }
    int find_set(int x) { ... }
    void union_sets(int a, int b) { ... }
};
```
