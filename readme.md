# Алгоритм Краскала
Данный алгоритм позволяет достаточно эффективно найти минимальное остовное дерево в связном графе.

## Постановка задачи
В файле `input.txt` в виде матрицы расстояний записан граф. Требуется найти минимальное остовное дерево с помощью алгоритма Краскала и вывести в файл `output.txt` суммарную длину всех его рёбер, а также сами эти рёбра.

## Псевдокод    
    G = граф
    E = список рёбер G
    удаляем все рёбра из G
    сортируем E по неубыванию длин
    T = пустой список рёбер минимального остовного дерева
    для каждого ребра e из E:
        a, b = вершины ребра e
        если a и b находятся в разных компонентах связности G:
            добавить в T ребро e
            объединить компоненты связности a и b ребром e

## Структуры данных
Ребро представлено в виде структуры, где `a` и `b` это вершины, которые ребро соединяет, а `l` это длина ребра.
```cpp
struct Edge {
    int a, b, l;
    ...
};
```
Изначальный граф и остовное дерево будем хранить в виде списков рёбер `std::vector<Edge>`. Для проверки и объединения компонент связности будем использовать СНМ, которая представлена в коде классом `DSU`.
```cpp
class DSU {
private:
    std::vector<int> parent, rank;
    int size = 0;
    ...
public:
    ...
    void make_set(int x) { ... }
    int find_set(int x) { ... }
    void union_sets(int a, int b) { ... }
};
```
## Как запустить
Первым делом нужно склонировать репозиторий
```sh
git clone git@github.com:zcimrn/kruskal
cd kruskal
```
После чего собрать с помощью `make`
```sh
make
```
Так как программа планирует читать граф из `input.txt`, необходимо его сгенерировать
```sh
./gen_test
```
После чего запускаем саму программу
```sh
./kruskal
```
Отлично, теперь правильный ответ записан в `output.txt`
